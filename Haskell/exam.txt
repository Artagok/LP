----------------------------------------------- INSTANCE / DERIVING -----------------------------------------------

data Queue a = Queue [a] [a]
    deriving (Show)

Define equality for queues so that two queues are equal if and only if they have the same elements, in the same order, 
independently of their representation. In order to do so, write that queues are an instance of the Eq class, where (==) is the equality operation you have to define:

instance Eq a => Eq (Queue a)
    where 
        (Queue l1 l2) == (Queue r1 r2) = l1' == r1'
            where
                l1' = l1 ++ reverse l2
                r1' = r1 ++ reverse r2

Observe that, in order to have Queue a be an instance of Eq, it is necessary to have that the elements of type a are them-selves also instances of Eq.


instance  (Eq a) => Eq (Tree a)  where
    (Leaf x)     == (Leaf y)        =  x == y
    (Branch l r) == (Branch l' r')  =  l == l' && r == r'
    _            == _               =  False


instance  (Ord a) => Ord (Tree a)  where
    (Leaf _)     <= (Branch _)      =  True
    (Leaf x)     <= (Leaf y)        =  x <= y
    (Branch _)   <= (Leaf _)        =  False
    (Branch l r) <= (Branch l' r')  =  l == l' && r <= r' || l <= l'


data Foo = Foo {x :: Integer, str :: String}
    deriving (Eq, Ord, Show, Read, Enum, Bounded)

----------------------------------------------- CLASS -----------------------------------------------

class  Eq a  where
    (==), (/=) :: a -> a -> Bool

        -- Minimal complete definition:
        --      (==) or (/=)
    x /= y     =  not (x == y)
    x == y     =  not (x /= y)


----------------------------------------------- DATA / TYPE -----------------------------------------------

data Configuration = Configuration
    String   -- User name
    String   -- Local host
    String   -- Remote host
    Bool     -- Is guest?
    Bool     -- Is superuser?
    String   -- Current directory
    String   -- Home directory
    Integer  -- Time connected
  deriving (Eq, Show)

data Configuration = Configuration
    { username      :: String
    , localHost     :: String
    , remoteHost    :: String
    , isGuest       :: Bool
    , isSuperuser   :: Bool
    , currentDir    :: String
    , homeDir       :: String
    , timeConnected :: Integer
    }

username :: Configuration -> String
localHost :: Configuration -> String



type String = [Char]
type AnniversaryBook = [Anniversary]


----------------------------------------------- MONADS / DO / I/O -----------------------------------------------


father :: Person -> Maybe Person
mother :: Person -> Maybe Person

bothGrandfathers :: Person -> Maybe (Person, Person)
    bothGrandfathers p =
        case father p of
            Nothing -> Nothing
            Just dad ->
                case father dad of
                    Nothing -> Nothing
                    Just gf1 ->                          -- found first grandfather
                        case mother p of
                            Nothing -> Nothing
                            Just mom ->
                                case father mom of
                                    Nothing -> Nothing
                                    Just gf2 ->          -- found second grandfather
                                        Just (gf1, gf2)

 bothGrandfathers p =
       father p >>=
           (\dad -> father dad >>=
               (\gf1 -> mother p >>=   -- gf1 is only used in the final return
                   (\mom -> father mom >>=
                       (\gf2 -> return (gf1,gf2) ))))

bothGrandfathers p = do {
        dad <- father p;
        gf1 <- father dad;
        mom <- mother p;
        gf2 <- father mom;
        return (gf1, gf2);
      }



putStr "Hello" >> 
putStr " " >> 
putStr "world!" >> 
putStr "\n"

do { putStr "Hello"
   ; putStr " "
   ; putStr "world!"
   ; putStr "\n" }


action1 >>= (\ x1 ->
  action2 >>= (\ x2 ->
    mk_action3 x1 x2 ))

do {  x1 <- action1
    ; x2 <- action2
    ; mk_action3 x1 x2 }


take m ys = case (m,ys) of
                (0,_)       ->  []
                (_,[])      ->  []
                (n,x:xs)    ->  x : take (n-1) xs

----------------------------------------------- UTILITIES -----------------------------------------------

words "John 120 18.53" = ["John","120","18.53"], separa l'string usant l'espai ' ' com a separador

read "123"::Float   = llegeix 123.0

els do es poden anidar
unless / when per condicionals amb valors monadics - dins d'un bloc do

main = do {
    line <- getLine;
    unless (line == "*") $ do {
        process line;
        main;
    }
}


Maybe a --> Just a | Nothing
Either String Int --> Left("Hola") | Right(12)


quickFib :: Int -> Int
quickFib n = fst (quickFib' n)
    where
        quickFib' 0     = (0, 0)
        quickFib' 1     = (1, 0)
        quickFib' n     = (res + ant, res)
            where
                (res, ant) = quickFib' (n-1)

----------------------------------------------- FUNCIONS -----------------------------------------------



Funcions sobre llistes habituals en Haskell

Aquesta lliÃ§Ã³ recull les funcions sobre llistes mÃ©s habituals en Haskell.
head, last

    Signatura:

      head, last :: [a] -> a

    DescripciÃ³:
        head xs Ã©s el primer element de la llista xs.

        last xs Ã©s el darrer element de la llista xs.

        Error si xs Ã©s buida.

    Exemples:

      Î»> head [1 .. 4]
      ðŸ‘‰ 1
      Î»> last [1 .. 4]
      ðŸ‘‰ 4

tail, init

    Signatura:

      tail, init :: [a] -> [a]

    DescripciÃ³:
        tail xs Ã©s la llista xs sense el seu primer element.

        init xs Ã©s la llista xs sense el seu darrer element.

        Error si xs Ã©s buida.

    Exemples:

      Î»> tail [1..4]
      ðŸ‘‰ [2, 3, 4]
      Î»> init [1..4]
      ðŸ‘‰ [1, 2, 3]

reverse

    Signatura:

      reverse :: [a] -> [a]

    DescripciÃ³:

    reverse xs Ã©s la llista xs del revÃ©s.

    Exemples:

      Î»> reverse [1..4]
      ðŸ‘‰ [4, 3, 2, 1]

length

    Signatura:

      length :: [a] -> Int

    DescripciÃ³:

    length xs Ã©s el nombre dâ€™elements a la llista xs.

null

    Signatura:

      null :: [a] -> Bool

    DescripciÃ³:

    null xs indica si la llista xs Ã©s buida.

elem

    Signatura:

      elem :: (Eq a) => a -> [a] -> Bool

    DescripciÃ³:

    elem x xs indica si x Ã©s a la llista xs.

(!!)

    Signatura:

      (!!) :: [a] -> Int -> a

    DescripciÃ³:

    xs !! i Ã©s lâ€™i-Ã¨sim element de la llista xs (comenÃ§ant per zero).

maximum, minimum

    Signatura:

      maximum, minimum :: (Ord a) => [a] -> a

    DescripciÃ³:
        maximum xs Ã©s lâ€™element mÃ©s gran de la llista (no buida!) xs.
        minimum xs Ã©s lâ€™element mÃ©s petit de la llista (no buida!) xs.

and, or

    Signatura:

      and, or :: [Bool] -> Bool

    DescripciÃ³:
        and bs Ã©s la conjunciÃ³ de la llista de booleans bs.
        or bs Ã©s la disjunciÃ³ de la llista de booleans bs.

sum, product

    Signatura:

      sum, product :: [Int] -> Int

    DescripciÃ³:
        sum xs Ã©s la suma de la llista dâ€™enters xs.
        prod xs Ã©s el producte de la llista dâ€™enters xs.

    Exemples:

      fact n = prod [1 .. n]

      Î»> fact 5
      ðŸ‘‰ 120

take, drop

    Signatura:

      take, drop :: Int -> [a] -> [a]

    DescripciÃ³:
        take n xs Ã©s el prefixe de llargada n de la llista `xs.
        drop n xs Ã©s el sufixe de la llista xs quan se li treuen els n primers elements.

    Exemples:

      Î»> take 3 [1 .. 7]
      ðŸ‘‰ [1, 2, 3]
      Î»> drop 3 [1 .. 7]
      ðŸ‘‰ [4, 5, 6, 7]

zip

    Signatura:

      zip :: [a] -> [b] -> [(a, b)]

    DescripciÃ³:

    zip xs ys Ã©s la llista que combina, en ordre, cada parell dâ€™elements de xs i ys. Si en falten, es perden.

    Exemples:

      Î»> zip [1, 2, 3] ['a', 'b', 'c']
      ðŸ‘‰ [(1, 'a'), (2, 'b'), (3, 'c')]
      Î»> zip [1 .. 10] [1 .. 3]
      ðŸ‘‰ [(1, 1), (2, 2), (3, 3)]

repeat

    Signatura:

      repeat :: a -> [a]

    DescripciÃ³:

    repeat x Ã©s la llista infinita on tots els elements sÃ³n x.

    Exemples:

      Î»> repeat 3
      ðŸ‘‰ [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ...]
      Î»> take 4 (repeat 3)
      ðŸ‘‰ [3, 3, 3, 3]

concat

    Signatura:

      concat :: [[a]] -> [a]

    DescripciÃ³:

    concat xs Ã©s la llista qie concatena totes les llistes de xs.

    Exemples:

      Î»> concat [[1, 2, 3], [], [3], [1, 2]]
      ðŸ‘‰ [1, 2, 3, 3, 1, 2]





Funcions dâ€™ordre superior habituals en Haskell

Aquesta lliÃ§Ã³ recull les funcions dâ€™ordre superior mÃ©s habituals en Haskell.
flip

    Signatura:

      flip :: (a -> b -> c) -> (b -> a -> c)

    DescripciÃ³:

    flip f retorna la funciÃ³ f perÃ² amb els seus dos parÃ metres invertits. Es defineix per

      flip f x y = f y x

    Exemples:

      Î»> meitat = flip div 2

      Î»> meitat 10
      ðŸ‘‰ 5

composiciÃ³ (.)

    Signatura:

      (.) :: (b -> c) -> (a -> b) -> a -> c

    DescripciÃ³:

    f . g Ã©s la composiciÃ³ de les funcions f i g.

    Exemples:

      Î»> majors3 = take 3 . reverse . sort

      Î»> majors3 [3, 1, 2, 6, 7]
      ðŸ‘‰ [7, 6, 3]

aplicaciÃ³ ($)

    Signatura:

      ($) :: (a -> b) -> a -> b

    DescripciÃ³:

    f $ x Ã©s el mateix que f x. Sembla inÃºtil, perÃ² degut a la baixa prioritat dâ€™aquest operador, ens permet ometre molts parÃ¨ntesis de tancar!

    Exemples:

      Î»> tail (tail (tail (tail "Jordi")))
      ðŸ‘‰ "i"
      Î»> tail $ tail $ tail $ tail "Jordi"
      ðŸ‘‰ "i"

map

    Signatura:

      map :: (a -> b) -> [a] -> [b]

    DescripciÃ³:

    map f xs Ã©s la llista que sâ€™obtÃ© al aplicar la funciÃ³ f a cada element de la llista xs, de forma que map f [x1, x2, ..., xn] Ã©s [f x1, f x2, ..., f xn].

    Exemples:

      Î»> map even [2, 4, 6, 7]
      ðŸ‘‰ [True, True, True, False]

      Î»> map (*2) [2, 4, 6, 7]
      ðŸ‘‰ [4, 8, 12, 14]

filter

    Signatura:

      filter :: (a -> Bool) -> [a] -> [a]

    DescripciÃ³:

    filter p xs Ã©s la subllista dels elements de xsque compleixen el predicat p.

    Exemples:

      Î»> filter even [2, 1, 4, 6, 7]
      ðŸ‘‰ [2, 4, 6]

zipWith

    Signatura:

      zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

    DescripciÃ³:

    zipWith op xs ys Ã©s la llista obtinguda operant cada element de xs amb cada element de ys via la funciÃ³ op, dâ€™esquerra a dreta, mentre nâ€™hi hagi.

    Exemples:

      Î»> zipWith (+) [1, 2, 3] [5, 1, 8, 9]
      ðŸ‘‰ [6, 3, 11]

all

    Signatura:

      all :: (a -> Bool) -> [a] -> Bool

    DescripciÃ³:

    all p xs indica si tots els elements de xs compleixen el predicat p.

    Exemples:

      Î»> all even [2, 1, 4, 6, 7]
      ðŸ‘‰ False
      Î»> all even [2, 4, 6]
      ðŸ‘‰ True

any

    Signatura:

      any :: (a -> Bool) -> [a] -> Bool

    DescripciÃ³:

    all p xs indica si algun dels elements de xs compleix el predicat p.

    Exemples:

      Î»> any even [2, 1, 4, 6, 7]
      ðŸ‘‰ True
      Î»> all odd [2, 4, 6]
      ðŸ‘‰ False

dropWhile

    Signatura:

      dropWhile :: (a -> Bool) -> [a] -> [a]

    DescripciÃ³:

    dropWhile p xs Ã©s la subllista de xs que elimina els primers elements de xs que compleixen el predicat p (fins al final o al primer qua no la compleix).

    Exemples:

      Î»> dropWhile even [2, 4, 6, 7, 8]
      ðŸ‘‰ [7, 8]
      Î»> dropWhile even [2, 4]
      ðŸ‘‰ []

takeWhile

    Signatura:

      takeWhile :: (a -> Bool) -> [a] -> [a]

    DescripciÃ³:

    takeWhile p xs Ã©s la subllista de xs que contÃ© els primers elements de xs que compleixen el predicat p (fins al final o al primer que no la compleix).

    Exemples:

      Î»> takeWhile even [2, 4, 6, 7, 8]
      ðŸ‘‰ [2, 4, 6]
      Î»> takeWhile even [1, 3]
      ðŸ‘‰ []

iterate

    Signatura:

      iterate :: (a -> a) -> a -> [a]

    DescripciÃ³:

    iterate f x retorna la llista infinita [x, f x, f (f x), f (f (f x)), ...].

    Exemples:

      Î»> iterate (*2) 1
      ðŸ‘‰ [1, 2, 4, 8, 16, ...]

foldl

    Signatura:

      foldl :: (b -> a -> b) -> b -> [a] -> b

    DescripciÃ³:

    foldl âŠ• x0 xs desplega un operador âŠ• per lâ€™esquerra, de forma que foldl âŠ• x0 [x1, x2, ..., xn] Ã©s (((x0 âŠ• x1) âŠ• x2) âŠ• ...) âŠ• xn.

    Exemples:

      Î»> foldl (+) 0 [3, 2, (-1)]
      ðŸ‘‰ 4

foldr

    Signatura:

      foldr :: (a -> b -> b) -> b -> [a] -> b

    DescripciÃ³:

    foldr âŠ• x0 xs desplega un operador per la dreta, de forma que foldr âŠ• x0 [x1, x2, ..., xn] Ã©s x1 âŠ• (x2 ... âŠ• (xn âŠ• x0))).

    Exemples:

      Î»> foldr (+) 0 [3, 2, (-1)]
      ðŸ‘‰ 4

scanl

    Signatura:

      scanl :: (b -> a -> b) -> b -> [a] -> [b]

    DescripciÃ³:

    scanl f z xs Ã©s com foldl f z xs perÃ² enlloc de retornar el valor final, retorna la llista amb tots els resultats intermigs.

    Exemples:

      Î»> scanl (+) 0 [3, 2, (-1)]
      ðŸ‘‰ [0, 3, 5, 4]

scanr

    Signatura:

      scanr :: (a -> b -> b) -> b -> [a] -> [b]

    DescripciÃ³:

    scanr f z xs Ã©s com foldr f z xs perÃ² enlloc de retornar el valor final, retorna la llista amb tots els resultats intermigs.

    Exemples:

      Î»> scanr (+) 0 [3, 2, (-1)]
      ðŸ‘‰ [4, 1, -1, 0]

const

    Signatura:

      const :: a -> b -> a

    DescripciÃ³:

    const x Ã©s una funciÃ³ que sempre retorna x, independentment de quÃ¨ se li apliqui.

    Exemples:

      Î»> map (const 42) [1 .. 5]
      ðŸ‘‰ [42, 42, 42, 42, 42]

id

    Signatura:

      id :: a -> a

    DescripciÃ³:

    id Ã©s la funciÃ³ identitat. TambÃ© sembla inÃºtil, pero va bÃ© en algun moment.

    Exemples:

      Î»> map id [1 .. 5]
      ðŸ‘‰ [1, 2, 3, 4, 5]